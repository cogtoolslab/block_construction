import numpy as np
from PIL import Image

from matplotlib import pylab, mlab, pyplot
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from matplotlib.path import Path
import matplotlib.patches as patches
import copy


### visualization helpers

def get_patch(verts,
              color='orange',
              line_width = 2):
    '''
    input:
        verts: array or list of (x,y) vertices of convex polygon. 
                last vertex = first vertex, so len(verts) is num_vertices + 1
        color: facecolor
        line_width: edge width    
    output:
        patch matplotlib.path patch object
    '''
    codes = [1] + [2]*(len(verts)-1)    ## 1 = MOVETO, 2 = LINETO
    path = Path(verts,codes)
    patch = patches.PathPatch(path, facecolor=color, lw=line_width)
    return patch


def render_blockworld(patches,
                      xlim=(-2,10),
                      ylim=(-2,10),
                      figsize=(4,4)):
    
    '''
    input: 
        patches: list of patches generated by get_patch() function
        xlim, ylim: axis limits
        figsize: defaults to square aspect ratio
    output:
        visualization of block placement
    '''
    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111)
    for patch in patches:
        ax.add_patch(patch)
    ax.set_xlim(xlim)
    ax.set_ylim(ylim)
    plt.show()




######################### DEFINITION OF BLOCK CLASS ################################
############### other blocks can inherit from the base block class #################

class BaseBlock:
    '''
    Base Block class for defining a block object with attributes
    '''
    
    def __init__(self, width=1, height=1, shape='rectangle', color='gray'):
        self.verts = np.array([(0, 0), 
                               (0, 1 * height), 
                               (1 * width, 1 * height), 
                               (1 * width, 0), 
                               (0,0)])
        self.width = width
        self.height = height
        self.shape = shape
        self.color = color
    
    def __str__(self):
        return(str(self.width) + 'x' + str(self.height))

    def init(self):
        self.corners = self.get_corners(self.verts)
        self.area = self.get_area(shape=self.shape) 
        
    def translate(self, verts, dx, dy):
        '''
        input:
            verts: array or list of (x,y) vertices of convex polygon. 
                    last vertex = first vertex, so len(verts) is num_vertices + 1
            dx, dy: distance to translate in each direction
        output:
            new vertices
        '''
        new_verts = copy.deepcopy(verts)
        new_verts[:,0] = verts[:,0] + dx
        new_verts[:,1] = verts[:,1] + dy
        return new_verts

    def get_corners(self,verts):
        '''
        input: list or array of block vertices in absolute coordinates
        output: absolute coordinates of top_left, bottom_left, bottom_right, top_right
        '''
        corners = {}
        corners['bottom_left'] = verts[0]
        corners['top_left'] = verts[1]
        corners['top_right'] = verts[2]
        corners['bottom_right'] = verts[3]
        return corners

    def get_area(self,shape='rectangle'):
        '''
        input: w = width 
               h = height           
               shape = ['rectangle', 'square', 'triangle']
        output
        '''
        ## extract width and height from dims dictionary 
        if shape in ['rectangle','square']:
            area = self.width*self.height
        elif shape=='triangle':
            area = self.width*self.height*0.5
        else:
            print('Shape type not recognized. Please use recognized shape type.')
        return area   



#################### DEFINITION OF BLOCK CLASS ###################################
############### this subclasses BaseBlock above ##################################

class Block:
    '''
        Creates Block objects that are instantiated in a world
    '''
    def __init__(self, base_block, x, y):
        self.base_block = base_block # defines height, width and other functions
        #bottom left coordinate
        self.x = x
        self.y = y
        self.height = base_block.height
        self.width = base_block.width
    
    
    
######################### SOME DRAWING FUNCTIONS ##########################
############### TODO: refactor ############################################    

def patch_for_block(b):
    return utils.get_patch(b.base_block.translate(b.base_block.verts,b.x,b.y),color=b.base_block.color)

def patches_for_floor(floor_blocks, xs):
    patches = []
    for (i, b) in enumerate(floor_blocks):
        patches.append(patch_for_block_here(b,xs[i],0))
    return patches

def drawFloor(floor_blocks, xs):
    utils.render_blockworld(patches_for_floor(floor_blocks, xs))
    
def patches_for_world(blocks):
    patches = []
    for (b) in blocks:
        patches.append(patch_for_block(b))
    return patches

def draw_world(world):
    utils.render_blockworld(patches_for_world(world.blocks)) 
    
######################### DEFINITION OF BLOCK WORLD CLASS ##########################
############### This class samples a block world. ##################################
    
# World Class
class World:       
    '''
    This class samples a block world. 
    
    Dependencies: 
        Block class. 
        Functions in utils.py.
    
    Input: block and world attributes
        block_dims: tuples defining width and height of types of allowable blocks
        block_colors: colors that will be mapped to these blocks
        world_width: width of world, this must be positive natural number
        world_height: height of world, this must be positive natural number        
    
    Output: filled block world
        blocks: list of blocks with attributes
        
    '''
    
    
    def __init__(self, 
                block_dims = [(1,1), # Blocks from left to right, thinest to thickest, shortest to tallest        
                            (1,2),
                            (2,1),
                            (2,2),
                            (2,4),
                            (4,2),
                            (4,4),
                            (8,2)
                            ],
                block_colors = ['#D33E43',
                            '#29335C',
                            '#EAEAEA',
                            '#0F8B8D',
                            '#2E3B44',
                            '#E79598',
                            '#8A8FA6',
                            '#91CACB',
                            '#B3B7BB',
                            '#D33E43',
                            '#EAEAEA'],
                world_width = 8, 
                world_height = 8):
                                
        
        # block parameters
        self.block_dims = block_dims
        self.block_colors = block_colors               
        self.base_blocks = [utils.BaseBlock(w,h,color=c) for ((w,h),c) in list(zip(sorted(block_dims),block_colors[0:len(block_dims)]))] # Block types should be in order from left to right, thinest to thickest, shortest to tallest
        self.block_widths = list(map(lambda b: b.width, self.base_blocks))         
        
        # world parameters
        self.world_width = world_width 
        self.world_height = world_height 
        self.block_map = np.zeros((self.world_width, self.world_height), dtype=int) ## bitmap for placement of blocks        
        self.blocks = []        
        self.full = False
        
    def check_full(self):
        '''
        Checks to see whether the World contains any empty space by summing block_map
        '''
        if not self.full:
            self.full = (sum(sum(self.block_map)) == self.world_width*self.world_height)
            return self.full
        else:
            return True
        
    def fill_floor(self, floor_space):
        '''
        Fills a 'floor', a level horizontal surface, with blocks.
        Input: Lexicon of blocks- np arrays with 5 coordinates; length of available floor space
        Output: List of blocks that can be used to fill the floor space with no gaps
        '''
        
        floor_blocks = []
        floor_block_widths = []
        viable_block_widths = copy.deepcopy(self.block_widths)
        remaining_space = floor_space
        while remaining_space > 0:
            i = np.random.randint(0,len(viable_block_widths))
            if self.block_widths[i] <= remaining_space:
                floor_blocks.append([self.base_blocks[i],floor_space-remaining_space])
                floor_block_widths.append(self.block_widths[i])
                remaining_space -= self.block_widths[i]
            else:
                viable_block_widths.pop()
        return(floor_blocks)

    def fill_floor_here(self, current_level, left_lim, right_lim):
        '''
        Fills a 'floor', a level horizontal surface, with blocks.
        Input: current_level: current height of floor we are trying to fill
               left_lim, right_lim: horizontal limits of current floor space to fill 
                                   (length of available floor space)
        Output: List of blocks that can be used to fill the floor space with no gaps
        '''
        
        floor_space = right_lim - left_lim
        floor_blocks = []
        floor_block_x_location = left_lim
        
        viable_block_widths = copy.deepcopy(self.block_widths)
        viable_blocks = copy.deepcopy(self.base_blocks)
        
        remaining_height = self.world_height - current_level
        remaining_space = floor_space
        
        while remaining_space > 0:
            i = np.random.randint(0,len(viable_blocks))
            base_block = self.base_blocks[i]
            if base_block.width <= remaining_space and base_block.height <= remaining_height: 
                b = utils.Block(self.base_blocks[i],floor_block_x_location,current_level)
                floor_block_x_location += b.width
                floor_blocks.append(b)
                self.blocks.append(b)
                remaining_space -= b.width
            else:
                viable_blocks.pop()
        self._update_map_with_floor_blocks(floor_blocks)

    def _update_map_with_floor_blocks(self, floor_blocks):
            for (i, b) in enumerate(floor_blocks):
                self.block_map[self.world_height-(b.y+b.height): self.world_height-b.y, b.x:(b.x+b.width)] = 1 
    
    def fill_world(self, render = True):
        '''
        Semi-randomly fills world with blocks, adding a 'floor' of blocks to the next available flat surface 
        '''
        current_level = 0 #Start at bottom and work up
        while current_level <= self.world_height - 1: # Until at top
            #find floor
            while self.block_map[self.world_height - current_level - 1].all() and current_level < self.world_height: # check if level is full or reached top
                current_level += 1
            if current_level == self.world_height:
                    break
            left = 0
            while self.block_map[self.world_height - current_level - 1][left] == 1:
                left += 1
            right = left
            while right < self.world_width and self.block_map[self.world_height - current_level - 1][right] == 0:
                right += 1
            #print('fill_world_here: ' + str((current_level, left, right)))
            self.fill_floor_here(current_level, left, right)
        
        ## check that world is filled
        self.check_full()
        
        ## optionally render world
        if render==True:
            draw_world(self)
            
    
    